<!doctype html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Yeni Yƒ±l √ái√ßek Kartƒ±</title>

  <style>
    html, body {
      overflow: hidden;
      padding: 0;
      margin: 0;
      height: 100%;
      background: #0b0f1a;
    }

    .container {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100vh;
    }

    canvas {
      position: absolute;
      inset: 0;
      display: block;
      width: 100%;
      height: 100%;
    }

    /* Orta y√∂nlendirme yazƒ±sƒ± */
    .name {
      position: fixed;
      top: 50%;
      left: 50%;
      width: min(900px, 92vw);
      transform: translate(-50%, -50%);
      color: white;
      text-align: center;
      font-size: 4vw;
      text-shadow: 0 0 12px rgba(0,0,0,.85);
      user-select: none;
      pointer-events: none;
      opacity: 0.95;
      transition: opacity .35s ease;
      padding: 0 18px;
      line-height: 1.15;
      z-index: 2;
    }
    @media (min-width: 640px) { .name { font-size: 44px; } }

    /* ---------------- Envelope + Button ---------------- */
    .envelope-wrap{
      position: fixed;
      inset: 0;
      display:flex;
      flex-direction: column;
      align-items:center;
      justify-content:center;
      gap: 16px;
      z-index: 5;
      pointer-events: auto;
    }
    .envelope-wrap.hidden{ display:none; }

    .envelope{
      position: relative;
      width: min(360px, 84vw);
      height: calc(min(360px, 84vw) * 0.62);
      cursor: default;
      filter: drop-shadow(0 22px 50px rgba(0,0,0,.55));
      transform: translateY(0);
    }

    /* IMPORTANT: clip wrapper keeps paper inside envelope */
    .env-clip{
      position: absolute;
      inset: 0;
      border-radius: 16px;
      overflow: hidden;
    }

    .env-back{
      position:absolute; inset:0;
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.22);
      border-radius: 16px;
      backdrop-filter: blur(7px);
      z-index: 1;
    }

    .env-paper{
      position:absolute;
      left: 18px; right: 18px;
      bottom: 12px;
      height: 86%;
      border-radius: 14px;
      background: rgba(255,255,255,.18);
      border: 1px solid rgba(255,255,255,.26);
      transform: translateY(22%);
      transition: transform .75s cubic-bezier(.18,.95,.2,1);
      overflow:hidden;
      z-index: 2;
    }
    .paper-top{
      height: 18px;
      background: rgba(255,255,255,.26);
    }

    .env-front{
      position:absolute; inset:0;
      border-radius: 16px;
      overflow:hidden;
      z-index: 3;
      pointer-events:none;
    }
    .env-front:before{
      content:"";
      position:absolute;
      inset:0;
      background: linear-gradient(135deg, rgba(255,255,255,.22), rgba(255,255,255,.08));
      clip-path: polygon(0 100%, 50% 44%, 100% 100%, 100% 0, 0 0);
      border: 1px solid rgba(255,255,255,.22);
      border-radius: 16px;
    }

    .env-flap{
      position:absolute;
      inset:0;
      border-radius: 16px;
      background: linear-gradient(180deg, rgba(255,255,255,.25), rgba(255,255,255,.06));
      clip-path: polygon(0 0, 100% 0, 50% 58%);
      transform-origin: top;
      transform: rotateX(0deg);
      transition: transform .65s cubic-bezier(.18,.95,.2,1);
      border-top: 1px solid rgba(255,255,255,.26);
      z-index: 5;
      pointer-events:none;
    }

    .env-seal{
      position:absolute;
      left:50%; top:56%;
      transform: translate(-50%,-50%);
      width: 56px; height: 56px;
      border-radius: 999px;
      display:flex; align-items:center; justify-content:center;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: rgba(255,255,255,.92);
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.25);
      text-shadow: 0 0 12px rgba(0,0,0,.75);
      z-index: 6;
      pointer-events:none;
    }

    /* Open state */
    .envelope.open .env-flap{ transform: rotateX(180deg); }
    .envelope.open .env-paper{ transform: translateY(-10%); }

    .open-btn{
      z-index: 6;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding: 12px 16px;
      min-width: 240px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.20);
      background: rgba(255,255,255,.08);
      color: rgba(255,255,255,.95);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      cursor: pointer;
      box-shadow: 0 18px 45px rgba(0,0,0,.35);
      backdrop-filter: blur(6px);
    }
    .open-btn:hover{ background: rgba(255,255,255,.12); }

    /* ---------------- Card overlay ---------------- */
    .card-overlay{
      position: fixed;
      inset: 0;
      z-index: 7;
      display:flex;
      align-items:center;
      justify-content:center;
      background: rgba(0,0,0,.38);
      backdrop-filter: blur(7px);
      padding: 18px;
    }
    .card-overlay.hidden{ display:none; }

    .card{
      width: min(560px, 92vw);
      border-radius: 22px;
      padding: 22px 20px;
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.22);
      color: rgba(255,255,255,.94);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      box-shadow: 0 30px 90px rgba(0,0,0,.55);
    }
    .card-title{
      font-size: 18px;
      letter-spacing: .4px;
      opacity: .95;
      margin-bottom: 10px;
    }
    .card-text{
      font-size: 18px;
      line-height: 1.65;
      white-space: pre-wrap;
      min-height: 150px;
    }
    .card-footer{
      margin-top: 14px;
      opacity: .85;
    }
    .card-close{
      margin-top: 16px;
      width: 100%;
      border-radius: 14px;
      padding: 12px 14px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.08);
      color: rgba(255,255,255,.92);
      cursor: pointer;
    }
    .card-close:hover{ background: rgba(255,255,255,.12); }
  </style>
</head>

<body>
  <div class="container">
    <canvas id="canvas"></canvas>
  </div>

  <div class="name" id="hintText">√ái√ßek eklemek i√ßin tƒ±kla üå∏</div>

  <!-- Envelope + Button -->
  <div id="envelopeWrap" class="envelope-wrap hidden">
    <div id="envelope" class="envelope" aria-label="Open letter">
      <div class="env-clip">
        <div class="env-back"></div>
        <div class="env-paper"><div class="paper-top"></div></div>
        <div class="env-front"></div>
        <div class="env-seal">‚ô°</div>
      </div>
      <div class="env-flap"></div>
    </div>

    <button id="openLetterBtn" class="open-btn" type="button">Mektubu A√ß</button>
  </div>

  <!-- Card -->
  <div id="cardOverlay" class="card-overlay hidden">
    <div class="card">
      <div class="card-title">Yeni Yƒ±l Mektubu</div>
      <div id="cardText" class="card-text"></div>
      <div class="card-footer"></div>
      <button id="cardClose" class="card-close">Kapat</button>
    </div>
  </div>

  <script type="x-shader/x-fragment" id="fragmentShader">
    #define PI 3.14159265359

    uniform float u_ratio;
    uniform vec2 u_cursor;
    uniform float u_stop_time;
    uniform float u_clean;
    uniform vec2 u_stop_randomizer;

    uniform sampler2D u_texture;
    varying vec2 vUv;

    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
    vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
    vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }
    float snoise(vec2 v) {
      const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
      vec2 i = floor(v + dot(v, C.yy));
      vec2 x0 = v - i + dot(i, C.xx);
      vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
      vec4 x12 = x0.xyxy + C.xxzz;
      x12.xy -= i1;
      i = mod289(i);
      vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
      vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);
      m = m*m; m = m*m;
      vec3 x = 2.0 * fract(p * C.www) - 1.0;
      vec3 h = abs(x) - 0.5;
      vec3 ox = floor(x + 0.5);
      vec3 a0 = x - ox;
      m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
      vec3 g;
      g.x = a0.x * x0.x + h.x * x0.y;
      g.yz = a0.yz * x12.xz + h.yz * x12.yw;
      return 130.0 * dot(m, g);
    }

    float get_flower_shape(vec2 _p, float _pet_n, float _angle, float _outline) {
      _angle *= 3.;
      _p = vec2(_p.x * cos(_angle) - _p.y * sin(_angle),
                _p.x * sin(_angle) + _p.y * cos(_angle));

      float a = atan(_p.y, _p.x);
      float flower_sectoral_shape = pow(abs(sin(a * _pet_n)), .4) + .25;

      vec2 flower_size_range = vec2(.03, .1);
      float size = flower_size_range[0] + u_stop_randomizer[0] * flower_size_range[1];

      float flower_radial_shape = pow(length(_p) / size, 2.);
      flower_radial_shape -= .1 * sin(8. * a);
      flower_radial_shape = max(.1, flower_radial_shape);
      flower_radial_shape += smoothstep(0., 0.03, -_p.y + .2 * abs(_p.x));

      float grow_time = step(.25, u_stop_time) * pow(u_stop_time, .3);
      float flower_shape = 1. - smoothstep(0., flower_sectoral_shape, _outline * flower_radial_shape / grow_time);

      flower_shape *= (1. - step(1., grow_time));
      return flower_shape;
    }

    float get_stem_shape(vec2 _p, vec2 _uv, float _w, float _angle) {
      _w = max(.004, _w);

      float x_offset = _p.y * sin(_angle);
      x_offset *= pow(3. * _uv.y, 2.);
      _p.x -= x_offset;

      float noise_power = .5;
      float cursor_horizontal_noise = noise_power * snoise(2. * _uv * u_stop_randomizer[0]);
      cursor_horizontal_noise *= pow(dot(_p.y, _p.y), .6);
      cursor_horizontal_noise *= pow(dot(_uv.y, _uv.y), .3);
      _p.x += cursor_horizontal_noise;

      float left = smoothstep(-_w, 0., _p.x);
      float right = 1. - smoothstep(0., _w, _p.x);
      float stem_shape = left * right;

      float grow_time = 1. - smoothstep(0., .2, u_stop_time);
      float stem_top_mask = smoothstep(0., pow(grow_time, .5), .03 -_p.y);
      stem_shape *= stem_top_mask;

      stem_shape *= (1. - step(.17, u_stop_time));
      return stem_shape;
    }

    void main() {
      vec3 base = texture2D(u_texture, vUv).xyz;

      vec2 uv = vUv;
      uv.x *= u_ratio;
      vec2 cursor = vUv - u_cursor.xy;
      cursor.x *= u_ratio;

      vec3 stem_color = vec3(.1 + u_stop_randomizer[0] * .6, .6, .2);
      vec3 flower_color = vec3(.6 + .5 * u_stop_randomizer[1], .1, .9 - .5 * u_stop_randomizer[1]);

      float angle = .5 * (u_stop_randomizer[0] - .5);

      float stem_shape = get_stem_shape(cursor, uv, .003, angle);
      stem_shape += get_stem_shape(cursor + vec2(0., .2 + .5 * u_stop_randomizer[0]), uv, .003, angle);
      float stem_mask = 1. - get_stem_shape(cursor, uv, .004, angle);
      stem_mask -= get_stem_shape(cursor + vec2(0., .2 + .5 * u_stop_randomizer[0]), uv, .004, angle);

      float petals_back_number = 1. + floor(u_stop_randomizer[0] * 2.);
      float angle_offset = -(2. * step(0., angle) - 1.) * .1 * u_stop_time;
      float flower_back_shape = get_flower_shape(cursor, petals_back_number, angle + angle_offset, 1.5);
      float flower_back_mask = 1. - get_flower_shape(cursor, petals_back_number, angle + angle_offset, 1.6);

      float petals_front_number = 2. + floor(u_stop_randomizer[1] * 2.);
      float flower_front_shape = get_flower_shape(cursor, petals_front_number, angle, 1.);
      float flower_front_mask = 1. - get_flower_shape(cursor, petals_front_number, angle, .95);

      vec3 color = base;
      color *= stem_mask;
      color *= flower_back_mask;
      color *= flower_front_mask;

      color += (stem_shape * stem_color);
      color += (flower_back_shape * (flower_color + vec3(0., .8 * u_stop_time, 0.)));
      color += (flower_front_shape * flower_color);

      color.r *= 1. - (.5 * flower_back_shape * flower_front_shape);
      color.b *= 1. - (flower_back_shape * flower_front_shape);

      color *= u_clean;

      gl_FragColor = vec4(color, 1.);
    }
  </script>

  <script type="x-shader/x-vertex" id="vertexShader">
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = vec4(position, 1.);
    }
  </script>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.133.1/build/three.module.js";

    const canvasEl = document.querySelector("#canvas");
    const hintEl = document.getElementById("hintText");

    const envelopeWrap = document.getElementById("envelopeWrap");
    const envelopeEl = document.getElementById("envelope");
    const openLetterBtn = document.getElementById("openLetterBtn");

    const cardOverlay = document.getElementById("cardOverlay");
    const cardText = document.getElementById("cardText");
    const cardClose = document.getElementById("cardClose");

    const pointer = { x: 0.66, y: 0.3, clicked: true };

    // thresholds
    const FINAL_AT = 14; // zarf ka√ß √ßi√ßekten sonra gelsin
    const SLOW_AT = 11;  // "yava≈üla" uyarƒ±sƒ±

    let flowerCount = 0;
    let finalUnlocked = false;
    let envelopeShown = false;

    let basicMaterial, shaderMaterial;

    const renderer = new THREE.WebGLRenderer({ canvas: canvasEl, alpha: true, antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x000000, 0);

    const sceneShader = new THREE.Scene();
    const sceneBasic = new THREE.Scene();
    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 10);
    const clock = new THREE.Clock();

    let renderTargets = [
      new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight),
      new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight),
    ];

    createPlane();
    updateSize();
    render();
    updateHint();

    window.addEventListener("resize", () => updateSize());

    let isTouchScreen = false;

    function canDraw() {
      return !finalUnlocked && !envelopeShown && cardOverlay.classList.contains("hidden");
    }

    window.addEventListener("click", (e) => {
      if (!canDraw()) return;
      if (!isTouchScreen) {
        pointer.x = e.pageX / window.innerWidth;
        pointer.y = e.pageY / window.innerHeight;
        pointer.clicked = true;
        onFlowerAdded();
      }
    });

    window.addEventListener("touchstart", (e) => {
      if (!canDraw()) return;
      isTouchScreen = true;
      pointer.x = e.targetTouches[0].pageX / window.innerWidth;
      pointer.y = e.targetTouches[0].pageY / window.innerHeight;
      pointer.clicked = true;
      onFlowerAdded();
    });

    function onFlowerAdded() {
      flowerCount++;
      updateHint();

      if (flowerCount >= FINAL_AT && !finalUnlocked) {
        finalUnlocked = true;
        setTimeout(showEnvelope, 650);
      }
    }

    function updateHint() {
      if (finalUnlocked) {
        hintEl.textContent = "Bir ≈üey geliyor‚Ä¶ ";
        return;
      }

      if (flowerCount < 3) {
        hintEl.textContent = "√ái√ßek eklemek i√ßin tƒ±kla ";
      } else if (flowerCount < 6) {
        hintEl.textContent = "Daha √ßok tƒ±kla ";
      } else if (flowerCount < SLOW_AT) {
        hintEl.textContent = "Harika gidiyor‚Ä¶ biraz daha tƒ±kla ";
      } else if (flowerCount < FINAL_AT) {
        hintEl.textContent = "Yakla≈ütƒ±n‚Ä¶ ≈üimdi yava≈üla ";
      } else {
        hintEl.textContent = "Tamam‚Ä¶ DURRRR ‚úâÔ∏è";
      }
    }

    function showEnvelope() {
      envelopeShown = true;
      hintEl.style.opacity = "0";
      envelopeWrap.classList.remove("hidden");
    }

    function typeWriter(text, el, speed = 100) {
      el.textContent = "";
      let i = 0;
      const timer = setInterval(() => {
        el.textContent += text[i] ?? "";
        i++;
        if (i > text.length) clearInterval(timer);
      }, speed);
    }

    function openCard() {
      const msg =
`2025'de hayatƒ±mda olduƒüun i√ßin √ßok ≈üanslƒ±yƒ±m.
Beni ben olarak anlayabilen tek ki≈üi olduƒüun i√ßin minnetarƒ±m.
Sen yanƒ±mdayken d√ºnya biraz daha yava≈üladƒ±.

D√º≈ü√ºncelerimde devrim yarattƒ±ƒüƒ±n, hayata olan bakƒ±≈üƒ±mƒ± deƒüi≈ütirdiƒüin,
beni g√ºld√ºrd√ºƒü√ºn, yanƒ±mda durduƒüun, hissettirdiklerin i√ßin te≈üekk√ºr ederim.
ƒ∞yi ki varsƒ±n ü§ç

2026'da birlikte bah√ßemize daha fazla √ßi√ßek ekmek dileƒüiyle.
Seni seviyorum eyl√ºl√ºm <3`;
      cardOverlay.classList.remove("hidden");
      typeWriter(msg, cardText, 100);
    }

    function openEnvelopeAndShowCard() {
      envelopeEl.classList.add("open");
      setTimeout(() => {
        envelopeWrap.classList.add("hidden");
        openCard();
      }, 900);
    }

    openLetterBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      openEnvelopeAndShowCard();
    });

    cardClose.addEventListener("click", () => {
      cardOverlay.classList.add("hidden");
    });

    function createPlane() {
      shaderMaterial = new THREE.ShaderMaterial({
        uniforms: {
          u_stop_time: { value: 0 },
          u_stop_randomizer: { value: new THREE.Vector2(Math.random(), Math.random()) },
          u_cursor: { value: new THREE.Vector2(pointer.x, pointer.y) },
          u_ratio: { value: window.innerWidth / window.innerHeight },
          u_texture: { value: null },
          u_clean: { value: 1 },
        },
        vertexShader: document.getElementById("vertexShader").textContent,
        fragmentShader: document.getElementById("fragmentShader").textContent,
      });

      basicMaterial = new THREE.MeshBasicMaterial();
      const planeGeometry = new THREE.PlaneGeometry(2, 2);

      sceneBasic.add(new THREE.Mesh(planeGeometry, basicMaterial));
      sceneShader.add(new THREE.Mesh(planeGeometry, shaderMaterial));
    }

    function render() {
      shaderMaterial.uniforms.u_texture.value = renderTargets[0].texture;

      if (pointer.clicked) {
        shaderMaterial.uniforms.u_cursor.value = new THREE.Vector2(pointer.x, 1 - pointer.y);
        shaderMaterial.uniforms.u_stop_randomizer.value = new THREE.Vector2(Math.random(), Math.random());
        shaderMaterial.uniforms.u_stop_time.value = 0;
        pointer.clicked = false;
      }

      shaderMaterial.uniforms.u_stop_time.value += clock.getDelta();

      renderer.setRenderTarget(renderTargets[1]);
      renderer.render(sceneShader, camera);

      basicMaterial.map = renderTargets[1].texture;

      renderer.setRenderTarget(null);
      renderer.render(sceneBasic, camera);

      const tmp = renderTargets[0];
      renderTargets[0] = renderTargets[1];
      renderTargets[1] = tmp;

      requestAnimationFrame(render);
    }

    function updateSize() {
      shaderMaterial.uniforms.u_ratio.value = window.innerWidth / window.innerHeight;
      renderer.setSize(window.innerWidth, window.innerHeight, false);
      renderTargets.forEach((rt) => rt.setSize(window.innerWidth, window.innerHeight));
    }
  </script>
</body>
</html>
